var S=Object.defineProperty;var L=s=>{throw TypeError(s)};var T=(s,i,e)=>i in s?S(s,i,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[i]=e;var P=(s,i,e)=>T(s,typeof i!="symbol"?i+"":i,e),O=(s,i,e)=>i.has(s)||L("Cannot "+e);var t=(s,i,e)=>(O(s,i,"read from private field"),e?e.call(s):i.get(s)),r=(s,i,e)=>i.has(s)?L("Cannot add the same private member more than once"):i instanceof WeakSet?i.add(s):i.set(s,e),n=(s,i,e,l)=>(O(s,i,"write to private field"),l?l.call(s,e):i.set(s,e),e);/* empty css     */var m,a,u;class H{constructor(i=[]){r(this,m);r(this,a,new Map);r(this,u,!1);n(this,m,i),this.initialize()}async initialize(){try{await Promise.all(t(this,m).map(i=>this.initializeModule(i))),!t(this,u)&&t(this,a).size===t(this,m).length&&console.log("ðŸ”§ [ App ] Modules initialized"),console.log("--------------------")}catch(i){console.error("Error initializing modules:",i)}}async initializeModule(i){try{await this.destroyModule(i);const e=new i;return typeof e.init=="function"&&await e.init(),t(this,a).set(i,e),e}catch(e){return console.error(`Module ${i.name} failed:`,e),null}}async destroyModule(i){const e=t(this,a).get(i);if(e)try{typeof e.destroy=="function"&&await Promise.resolve(e.destroy()),Object.entries(e).filter(([l,g])=>g&&typeof g=="number").forEach(([l,g])=>{clearTimeout(g),clearInterval(g)}),Object.getOwnPropertySymbols(e).forEach(l=>e[l]=null),t(this,a).delete(i),await new Promise(l=>setTimeout(l,50))}catch(l){console.error(`Error destroying module ${i.name}:`,l)}}async refreshModules(){if(!t(this,u))try{n(this,u,!0),await Promise.all([...t(this,a).keys()].map(i=>this.destroyModule(i))),t(this,a).clear(),await new Promise(i=>setTimeout(i,50)),await this.initialize()}catch(i){console.error("Error refreshing modules:",i)}finally{n(this,u,!1)}}}m=new WeakMap,a=new WeakMap,u=new WeakMap;class R{constructor(i){this.autoInitializer=i,this.setupHMR()}setupHMR(){}}var o,p,z,h,w,c,y,v,b,M;const d=class d{constructor(){r(this,o);r(this,p,100);r(this,z,!1);r(this,h);r(this,w);r(this,c);r(this,v,i=>{t(this,o)&&i.forEach(e=>t(this,o).classList.toggle("visible",e.isIntersecting))});r(this,b,()=>window.addEventListener("scroll",t(this,c),{passive:!0}));r(this,M,()=>{if(!t(this,o))return;const i=window.scrollY>t(this,p);i!==t(this,z)&&(n(this,z,i),t(this,o).classList.toggle("scrolled",i))});if(!t(d,y)){if(n(d,y,!0),n(this,o,document.querySelector("header")),!t(this,o)){console.warn("Header element not found in the DOM");return}n(this,c,t(this,M).bind(this))}}async init(){t(this,o)&&(n(this,h,new IntersectionObserver(i=>t(this,v).call(this,i),{threshold:[0,.5,1]})),t(this,h).observe(t(this,o)),t(this,b).call(this))}destroy(){n(d,y,!1),t(this,w)&&(clearTimeout(t(this,w)),n(this,w,null)),t(this,h)&&(t(this,h).disconnect(),n(this,h,null)),t(this,c)&&(window.removeEventListener("scroll",t(this,c)),n(this,c,null)),t(this,o)&&(t(this,o).classList.remove("visible","scrolled"),n(this,o,null))}};o=new WeakMap,p=new WeakMap,z=new WeakMap,h=new WeakMap,w=new WeakMap,c=new WeakMap,y=new WeakMap,v=new WeakMap,b=new WeakMap,M=new WeakMap,r(d,y,!1);let E=d;const f=class f{constructor(){if(f.instance)return f.instance;this.modules=[E],this.init(),f.instance=this}init(){this.autoInitializer=new H(this.modules),new R(this.autoInitializer),console.log("--------------------"),console.log("ðŸ’¡ [ App ] initialize ")}registerModule(i){this.modules.push(i),this.autoInitializer.initializeModule(i)}};P(f,"instance",null);let I=f;new I;
//# sourceMappingURL=app.js.map
